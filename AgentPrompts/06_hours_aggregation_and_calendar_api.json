{
  "task": "hours_aggregation_and_calendar_api",
  "role": "backend_engineer",
  "objective": "Implement API endpoints that aggregate tutoring hours from MSSQL tblSessionSchedule (deduping hour blocks by ScheduleDate+TimeID) and approved extra hours from Postgres extrahours (status='approved'). Provide weekly, pay-period, and monthly totals for the authenticated tutor, plus a month calendar view of tutoring schedule. All date math must be timezone-correct using the pay period service outputs and franchise timezone. No cross-db SQL is allowed; aggregate via separate queries in the API layer.",
  "constraints": {
    "no_cross_db_sql": true,
    "no_schema_changes": true,
    "no_startup_db_tests": true,
    "only_api_layer_accesses_dbs": true,
    "timezone_correct": true,
    "use_pay_period_service": true
  },
  "dependencies": {
    "requires": [
      "auth sessions: session.accountType, session.accountId, session.franchiseId",
      "pay period service logic (task 05) accessible as internal function or via module import",
      "MSSQL connector module (no connect on import)",
      "Postgres connector module (no connect on import)"
    ],
    "mssql_tables": ["dbo.tblSessionSchedule", "dbo.tblTimes"],
    "postgres_tables": ["public.extrahours"]
  },
  "definitions": {
    "tutoring_hour_block": "One tutoring hour is defined as a unique (ScheduleDate, TimeID) pair for a TutorID in tblSessionSchedule, regardless of how many student rows exist for that tutor/date/time slot.",
    "extra_hours_inclusion": "Include ONLY extrahours rows where status='approved'. Duration is computed as (end_at - start_at) and aggregated into decimal hours.",
    "bounds_semantics": "All Postgres aggregations must use UTC bounds [startAt, endAt) produced by task 05 or equivalent Luxon-derived bounds. All MSSQL ScheduleDate filters must use local DATE bounds derived from the same local date ranges to avoid off-by-one issues."
  },
  "required_helpers": [
    {
      "name": "minutesToHoursDecimal",
      "signature": "(minutes: number) => number",
      "requirements": [
        "Convert minutes to decimal hours (minutes/60).",
        "Do not round during aggregation; round only for output."
      ]
    },
    {
      "name": "roundHours2",
      "signature": "(hours: number) => number",
      "requirements": ["Round to 2 decimals using standard rounding."]
    }
  ],
  "sql_reference": {
    "important_notes": [
      "MSSQL queries MUST dedupe by (ScheduleDate, TimeID) via GROUP BY or CTE Slots and then COUNT(*) of Slots.",
      "Postgres extra hours MUST filter by tutorid AND status='approved' AND start_at within [startAtUtc, endAtUtc).",
      "MSSQL uses DATE bounds (local); Postgres uses timestamptz bounds (UTC). Do not mix."
    ],
    "weekly": {
      "mssql_tutoring_hours": "DECLARE @StartOfThisWeek DATE = @p_start_of_week;\nDECLARE @StartOfNextWeek DATE = @p_start_of_next_week;\n\n;WITH Slots AS (\n    SELECT TutorID, ScheduleDate, TimeID\n    FROM dbo.tblSessionSchedule\n    WHERE TutorID = @p_tutor_id\n      AND ScheduleDate >= @StartOfThisWeek\n      AND ScheduleDate <  @StartOfNextWeek\n    GROUP BY TutorID, ScheduleDate, TimeID\n)\nSELECT COUNT(*) AS weekly_tutoring_hours\nFROM Slots;",
      "postgres_extra_hours": "SELECT\n  COALESCE(SUM(EXTRACT(EPOCH FROM (end_at - start_at)) / 3600.0), 0) AS weekly_extra_hours\nFROM public.extrahours\nWHERE tutorid = $1\n  AND status = 'approved'\n  AND start_at >= $2\n  AND start_at <  $3;",
      "total_formula": "weekly_total_hours = weekly_tutoring_hours + weekly_extra_hours"
    },
    "pay_period": {
      "mssql_tutoring_hours": "DECLARE @PeriodStart DATE = @p_period_start;\nDECLARE @PeriodEnd   DATE = @p_period_end;\n\n;WITH Slots AS (\n    SELECT TutorID, ScheduleDate, TimeID\n    FROM dbo.tblSessionSchedule\n    WHERE TutorID = @p_tutor_id\n      AND ScheduleDate >= @PeriodStart\n      AND ScheduleDate <= @PeriodEnd\n    GROUP BY TutorID, ScheduleDate, TimeID\n)\nSELECT COUNT(*) AS pay_period_tutoring_hours\nFROM Slots;",
      "postgres_extra_hours": "SELECT\n  COALESCE(SUM(EXTRACT(EPOCH FROM (end_at - start_at)) / 3600.0), 0) AS pay_period_extra_hours\nFROM public.extrahours\nWHERE tutorid = $1\n  AND status = 'approved'\n  AND start_at >= $2\n  AND start_at <  $3;",
      "total_formula": "pay_period_total_hours = pay_period_tutoring_hours + pay_period_extra_hours"
    },
    "monthly": {
      "mssql_tutoring_hours": "DECLARE @MonthStart DATE = @p_month_start;\nDECLARE @NextMonthStart DATE = @p_next_month_start;\n\n;WITH Slots AS (\n    SELECT TutorID, ScheduleDate, TimeID\n    FROM dbo.tblSessionSchedule\n    WHERE TutorID = @p_tutor_id\n      AND ScheduleDate >= @MonthStart\n      AND ScheduleDate <  @NextMonthStart\n    GROUP BY TutorID, ScheduleDate, TimeID\n)\nSELECT COUNT(*) AS monthly_tutoring_hours\nFROM Slots;",
      "postgres_extra_hours": "SELECT\n  COALESCE(SUM(EXTRACT(EPOCH FROM (end_at - start_at)) / 3600.0), 0) AS monthly_extra_hours\nFROM public.extrahours\nWHERE tutorid = $1\n  AND status = 'approved'\n  AND start_at >= $2\n  AND start_at <  $3;",
      "total_formula": "monthly_total_hours = monthly_tutoring_hours + monthly_extra_hours"
    },
    "calendar_month": {
      "mssql_calendar_entries": "DECLARE @MonthStart DATE = @p_month_start;\nDECLARE @NextMonthStart DATE = @p_next_month_start;\n\nSELECT\n    s.ScheduleDate,\n    s.TimeID,\n    t.Time AS TimeLabel\nFROM dbo.tblSessionSchedule s\nJOIN dbo.tblTimes t ON s.TimeID = t.ID\nWHERE s.TutorID = @p_tutor_id\n  AND s.ScheduleDate >= @MonthStart\n  AND s.ScheduleDate <  @NextMonthStart\nGROUP BY s.ScheduleDate, s.TimeID, t.Time\nORDER BY s.ScheduleDate ASC, s.TimeID ASC;"
    }
  },
  "endpoint_contracts": [
    {
      "method": "GET",
      "path": "/api/hours/me/weekly",
      "auth": "tutor",
      "behavior": [
        "Compute local ISO week range (Monday start) in franchise timezone.",
        "MSSQL tutoring hours: apply local DATE bounds [startDate, nextWeekStartDate) using the exact SQL in sql_reference.weekly.mssql_tutoring_hours.",
        "Postgres extra hours: apply UTC bounds [startAt, endAt) using the exact SQL in sql_reference.weekly.postgres_extra_hours.",
        "Return tutoringHours integer, extraHours decimal rounded to 2dp, totalHours rounded to 2dp."
      ],
      "response": {
        "status": 200,
        "body": {
          "range": { "startDate": "YYYY-MM-DD", "endDate": "YYYY-MM-DD", "timezone": "string" },
          "tutoringHours": "number (integer)",
          "extraHours": "number (decimal, 2dp)",
          "totalHours": "number (decimal, 2dp)"
        }
      }
    },
    {
      "method": "GET",
      "path": "/api/hours/me/pay-period",
      "auth": "tutor",
      "behavior": [
        "Resolve current pay period using task 05 for tutor's franchiseId.",
        "MSSQL tutoring hours: use payPeriod.startDate/payPeriod.endDate as DATE bounds (inclusive end for MSSQL per SQL reference).",
        "Postgres extra hours: use payPeriod.startAt/payPeriod.endAt as UTC timestamp bounds [startAt, endAt).",
        "Return payPeriod object plus tutoringHours, extraHours, totalHours."
      ],
      "response": {
        "status": 200,
        "body": {
          "payPeriod": "pay_period object from task 05",
          "tutoringHours": "number (integer)",
          "extraHours": "number (decimal, 2dp)",
          "totalHours": "number (decimal, 2dp)"
        }
      }
    },
    {
      "method": "GET",
      "path": "/api/hours/me/monthly",
      "auth": "tutor",
      "query_params": { "month": "YYYY-MM (optional; defaults to current month in franchise timezone)" },
      "behavior": [
        "Compute local month range in franchise timezone: monthStartDate and nextMonthStartDate.",
        "MSSQL tutoring hours: apply local DATE bounds [monthStartDate, nextMonthStartDate) using exact SQL in sql_reference.monthly.mssql_tutoring_hours.",
        "Postgres extra hours: apply UTC bounds [monthStartAtUtc, nextMonthStartAtUtc) using exact SQL in sql_reference.monthly.postgres_extra_hours.",
        "Return tutoringHours, extraHours, totalHours and range."
      ],
      "response": {
        "status": 200,
        "body": {
          "range": { "month": "YYYY-MM", "startDate": "YYYY-MM-DD", "endDate": "YYYY-MM-DD", "timezone": "string" },
          "tutoringHours": "number (integer)",
          "extraHours": "number (decimal, 2dp)",
          "totalHours": "number (decimal, 2dp)"
        }
      }
    },
    {
      "method": "GET",
      "path": "/api/calendar/me/month",
      "auth": "tutor",
      "query_params": { "month": "YYYY-MM (optional; defaults to current month in franchise timezone)" },
      "behavior": [
        "Compute local month range in franchise timezone: monthStartDate and nextMonthStartDate.",
        "Query MSSQL for distinct schedule blocks using exact SQL in sql_reference.calendar_month.mssql_calendar_entries.",
        "Return entries sorted by date then time."
      ],
      "response": {
        "status": 200,
        "body": {
          "range": { "month": "YYYY-MM", "startDate": "YYYY-MM-DD", "endDate": "YYYY-MM-DD", "timezone": "string" },
          "entries": [
            { "scheduleDate": "YYYY-MM-DD", "timeId": "number", "timeLabel": "string" }
          ]
        }
      }
    }
  ],
  "implementation_notes": [
    "Use Luxon for weekly/monthly bounds in franchise timezone.",
    "Prefer reusing task 05 helper(s) to convert local ranges to UTC bounds, to avoid DST issues.",
    "Do not include pending/denied extra hours in totals.",
    "Do not round intermediate sums; only round final output fields extraHours and totalHours to 2 decimals."
  ],
  "acceptance_criteria": [
    "Tutoring hours are deduped by (ScheduleDate, TimeID) per TutorID using the exact MSSQL query structure in sql_reference.",
    "Only Postgres extrahours with status='approved' are included.",
    "Weekly range starts Monday in franchise timezone.",
    "Pay-period aggregation uses task 05 output and respects overrides.",
    "All queries are parameterized and executed only in the API layer.",
    "Calendar entries are distinct blocks and deterministically ordered."
  ]
}
