{
  "task": "pay_period_resolution_service",
  "role": "backend_engineer",
  "objective": "Implement a deterministic pay period resolution service that computes the correct pay period window for a given franchise and local date, honoring Postgres payroll settings and overrides. Outputs must include both local (YYYY-MM-DD) dates for UI and UTC timestamps (startAt inclusive, endAt exclusive) for query bounds.",
  "constraints": {
    "timezone_correct": true,
    "deterministic": true,
    "overrides_take_precedence": true,
    "no_schema_changes": true,
    "no_db_connection_tests_at_startup": true,
    "no_franchise_emails_in_postgres": true
  },
  "dependencies": {
    "requires_tables": [
      "public.franchise_payroll_settings",
      "public.franchise_pay_period_overrides"
    ],
    "settings_source": "Postgres only",
    "override_source": "Postgres only"
  },
  "required_library": {
    "timezone_math": "luxon"
  },
  "required_helpers": [
    {
      "name": "parseLocalDate",
      "signature": "(dateISO: string | null, timezone: string) => DateTime",
      "requirements": [
        "If dateISO is null, treat as 'today' in the provided timezone.",
        "Interpret dateISO as a local date (YYYY-MM-DD) in the provided timezone.",
        "Return a Luxon DateTime at start of day in the provided timezone."
      ]
    },
    {
      "name": "localDateRangeToUtcBounds",
      "signature": "(startLocal: DateTime, endLocal: DateTime) => { startAtUtcISO: string, endAtUtcISO: string }",
      "requirements": [
        "startAtUtcISO represents startLocal at 00:00:00 in timezone converted to UTC (inclusive bound).",
        "endAtUtcISO represents (endLocal + 1 day) at 00:00:00 in timezone converted to UTC (exclusive bound).",
        "endLocal is treated as inclusive for display; endAtUtcISO must be exclusive for queries."
      ]
    },
    {
      "name": "formatLocalDateISO",
      "signature": "(dt: DateTime) => string",
      "requirements": [
        "Return YYYY-MM-DD in the DateTime's zone."
      ]
    },
    {
      "name": "getLastDayOfMonth",
      "signature": "(dt: DateTime) => DateTime",
      "requirements": [
        "Return a DateTime representing the last day of dt's month, same zone, startOf('day')."
      ]
    }
  ],
  "pay_period_object": {
    "franchiseId": "number",
    "timezone": "string (IANA timezone)",
    "periodType": "weekly|biweekly|semimonthly|monthly",
    "startDate": "YYYY-MM-DD (local)",
    "endDate": "YYYY-MM-DD (local, inclusive)",
    "startAt": "ISO timestamp (UTC, inclusive bound)",
    "endAt": "ISO timestamp (UTC, exclusive bound)",
    "source": "override|computed",
    "overrideId": "number|null",
    "resolvedForDate": "YYYY-MM-DD (local)"
  },
  "settings_resolution_rules": [
    "Fetch franchise_payroll_settings by franchiseId.",
    "If not found, use defaults: timezone='America/Los_Angeles', pay_period_type='biweekly', policytype='strict_approval', auto_email_enabled=false."
  ],
  "override_rules": [
    "If an override exists for franchiseId where forDate (local) is between periodstart and periodend inclusive, return that override as the pay period.",
    "If multiple overrides match, choose the most recent by createdat; if tie, choose the highest id.",
    "Overrides must always take precedence over computed periods."
  ],
  "computation_rules": {
    "general": [
      "All computation uses the franchise timezone from settings.",
      "All outputs must be deterministic for identical inputs."
    ],
    "weekly": [
      "Week starts Monday (ISO week) at 00:00 local.",
      "startLocal = forDate.startOf('week') in local timezone.",
      "endLocal = startLocal + 6 days."
    ],
    "biweekly": [
      "Biweekly is implemented as a deterministic 14-day interval anchored to an epoch date.",
      "Use BIWEEKLY_ANCHOR_DATE env var (YYYY-MM-DD) if present; otherwise default to '2024-01-01'.",
      "Interpret anchor date as local date in franchise timezone.",
      "Compute k = floor( daysBetween(anchorLocal, forDateLocal) / 14 ).",
      "startLocal = anchorLocal + (k * 14) days.",
      "endLocal = startLocal + 13 days."
    ],
    "semimonthly": [
      "Semimonthly default is fixed: 1st–15th and 16th–last day of month (local).",
      "If forDate.day <= 15: startLocal = first day of month, endLocal = 15th.",
      "Else: startLocal = 16th, endLocal = last day of month."
    ],
    "monthly": [
      "Monthly is calendar month: startLocal = first day of month, endLocal = last day of month."
    ],
    "future_note": [
      "Do not implement semimonthly custom anchors (e.g., 5th/20th) in this task unless the settings already include it. Keep logic modular so it can be added later."
    ]
  },
  "required_endpoints": [
    {
      "method": "GET",
      "path": "/api/pay-period/current",
      "auth": "required",
      "behavior": [
        "Resolve franchiseId from session context. For tutors: use session.franchiseId; ignore franchiseId query params if present.",
        "For admins: require franchiseId query param OR a previously established admin franchise scope in session (if exists). If neither exists, return 400.",
        "Use forDate = today in the franchise timezone."
      ],
      "response": { "status": 200, "body": { "payPeriod": "pay_period_object" } }
    },
    {
      "method": "GET",
      "path": "/api/pay-period",
      "auth": "required",
      "query_params": {
        "franchiseId": "number (required for admin; ignored for tutor)",
        "forDate": "YYYY-MM-DD (optional; defaults to today in franchise timezone)"
      },
      "behavior": [
        "Tutor requests ignore franchiseId param and always use session.franchiseId.",
        "Admin requests must specify franchiseId (or have admin scope in session).",
        "Return computed or override period as payPeriod."
      ],
      "response": { "status": 200, "body": { "payPeriod": "pay_period_object" } }
    }
  ],
  "errors": [
    {
      "case": "missing_franchise_context",
      "status": 400,
      "body": { "error": "franchiseId is required for admin requests" }
    },
    {
      "case": "invalid_forDate",
      "status": 400,
      "body": { "error": "forDate must be YYYY-MM-DD" }
    }
  ],
  "acceptance_criteria": [
    "Overrides take precedence over computed periods.",
    "For identical inputs (franchiseId, timezone, settings, overrides, forDate), the output is identical (deterministic).",
    "startAt/endAt are correct UTC bounds corresponding to local startDate/endDate with [startAt, endAt) semantics.",
    "Weekly starts Monday local time.",
    "Biweekly uses a fixed anchor date (env override supported) and produces consistent 14-day windows.",
    "Tutor cannot request a different franchiseId via query param.",
    "Admin must specify franchiseId (or have session scope) to resolve pay periods."
  ]
}
