{
  "task": "time_off_requests_postgres_api_with_google_calendar",
  "role": "fullstack_engineer",
  "objective": "Build an in-app Time Off Request form and full API workflow backed by Postgres (Neon) as the source of truth. Tutors submit requests; admins approve/deny. On approval, the server must create a Google Calendar event on the center's primary calendar using Google Workspace Domain-Wide Delegation (DWD) by impersonating dbo.tblFranchies.GmailID. Store the created event id in Postgres so future update/cancel can be implemented safely.",
  "constraints": {
    "timezone_correct": true,
    "no_startup_db_tests": true,
    "api_layer_only_db_access": true,
    "audit_trail_required": true,
    "no_self_approval": true,
    "use_postgres_as_source_of_truth": true,
    "google_calendar_insert_required_on_approval": true,
    "google_calendar_auth_is_dwd": true
  },
  "google_calendar_integration": {
    "enabled": true,
    "auth_model": "service_account_domain_wide_delegation",
    "impersonation_subject_source": "MSSQL dbo.tblFranchies.GmailID by franchiseId",
    "calendar_id_rule": "calendarId = GmailID (primary calendar)",
    "scopes": ["https://www.googleapis.com/auth/calendar.events"],
    "event_shape": {
      "summary_template": "TIME OFF: {TutorName} ({Type})",
      "description_requirements": [
        "Tutor name + tutor id",
        "Franchise id",
        "Time off type",
        "Notes (if any)",
        "Request id"
      ],
      "start_end": "Use RFC3339 dateTime with timezone offset; persist canonical timestamptz in Postgres."
    },
    "failure_policy": {
      "on_calendar_insert_failure": "Do not mark request approved; return 502 with a clear error. Keep request pending so admin can retry.",
      "retry_strategy": "Allow admin to retry approval (same endpoint) while status is pending.",
      "idempotency": "If a google_calendar_event_id already exists on a pending request, do not create a second event; instead return conflict 409 and instruct admin to use a dedicated 'retry calendar sync' endpoint (not implemented in this task)."
    }
  },
  "data_model": {
    "table": "public.time_off_requests",
    "required_columns": [
      "id",
      "franchiseid",
      "tutorid",
      "start_at",
      "end_at",
      "type",
      "notes",
      "status",
      "created_at",
      "created_by",
      "decided_at",
      "decided_by",
      "decision_reason",
      "google_calendar_event_id"
    ],
    "status_model": {
      "allowed_statuses": ["pending", "approved", "denied", "cancelled"],
      "allowed_transitions": [
        "pending -> approved",
        "pending -> denied",
        "pending -> cancelled"
      ]
    },
    "types": {
      "type_allowed": ["pto", "sick", "unpaid", "other"]
    }
  },
  "validation_rules": [
    "Tutor can only create/cancel their own requests; derive tutorId/franchiseId from session.",
    "startAt must be < endAt.",
    "Duration must be > 0 and <= MAX_TIME_OFF_DURATION_HOURS env (default 336).",
    "Type must be one of pto/sick/unpaid/other.",
    "Notes optional, trimmed, max 2000 chars.",
    "Cancel allowed only if status='pending'.",
    "Admin decide allowed only if status='pending'.",
    "Franchise scope enforced for admin list + decide.",
    "No self-approval enforced: admin cannot approve/deny if request.tutorid == session.accountId.",
    "Optional overlap check controlled by ENFORCE_TIMEOFF_OVERLAP (default false)."
  ],
  "required_helpers": [
    {
      "name": "buildGcalClientForSubject",
      "signature": "(subjectEmail: string) => CalendarClient",
      "requirements": [
        "Uses GOOGLE_SERVICE_ACCOUNT_JSON from env.",
        "Uses DWD impersonation via JWT subject=subjectEmail.",
        "Uses scope calendar.events."
      ]
    },
    {
      "name": "buildGcalEventPayload",
      "signature": "(request, tutorIdentity) => object",
      "requirements": [
        "summary uses template in google_calendar_integration.event_shape.summary_template",
        "description includes requestId and required metadata",
        "start.dateTime and end.dateTime filled from request start/end"
      ]
    }
  ],
  "endpoints": [
    {
      "method": "POST",
      "path": "/api/timeoff",
      "auth": "tutor",
      "body": {
        "startAt": "ISO timestamp",
        "endAt": "ISO timestamp",
        "type": "pto|sick|unpaid|other",
        "notes": "string (optional)"
      },
      "behavior": [
        "Derive tutorId and franchiseId from session.",
        "Validate per rules.",
        "Optionally enforce overlap if ENFORCE_TIMEOFF_OVERLAP=true.",
        "Insert into Postgres time_off_requests with status='pending'.",
        "Write audit entry action='created'.",
        "Return created request."
      ]
    },
    {
      "method": "GET",
      "path": "/api/timeoff/me",
      "auth": "tutor",
      "behavior": [
        "Return tutor's own requests with optional filters.",
        "Sort by start_at desc."
      ]
    },
    {
      "method": "POST",
      "path": "/api/timeoff/{id}/cancel",
      "auth": "tutor",
      "behavior": [
        "Only if status pending and belongs to tutor.",
        "Update status cancelled; write audit entry."
      ]
    },
    {
      "method": "GET",
      "path": "/api/timeoff/admin/pending",
      "auth": "admin",
      "query_params": {
        "franchiseId": "number (required)"
      },
      "behavior": [
        "Return pending requests for franchiseId.",
        "Batch lookup tutor identity from MSSQL dbo.tblTutors (single IN query).",
        "Sort created_at asc."
      ]
    },
    {
      "method": "POST",
      "path": "/api/timeoff/{id}/decide",
      "auth": "admin",
      "body": {
        "decision": "approve|deny",
        "reason": "string (optional; required if deny)"
      },
      "behavior": [
        "Fetch request from Postgres.",
        "Authorize franchise scope and enforce no self-approval.",
        "If decision=deny: update status denied (no calendar write). Write audit.",
        "If decision=approve:",
        "  1) Read center GmailID from MSSQL dbo.tblFranchies.GmailID by franchiseId.",
        "  2) Read tutor identity from MSSQL dbo.tblTutors (FirstName/LastName/Email) by tutorId for event summary/description.",
        "  3) Build DWD calendar client with subject=GmailID.",
        "  4) Insert event into calendarId=GmailID (primary calendar).",
        "  5) If insert succeeds: update Postgres request status approved AND set google_calendar_event_id=event.id, decided_at/by/reason.",
        "  6) Write audit entry approved including google_calendar_event_id.",
        "  7) Return updated request.",
        "  8) If insert fails: do NOT approve; keep pending; return error."
      ]
    }
  ],
  "ui_requirements": {
    "tutor": [
      "Time Off form page (start/end/type/notes) -> POST /api/timeoff",
      "My Time Off Requests list (status + cancel pending)",
      "Calendar overlay (optional in this task; OK to only show list for MVP)"
    ],
    "admin": [
      "Pending time off list for franchise with Approve/Deny",
      "Deny requires reason",
      "On Approve: show success and remove from pending"
    ]
  },
  "acceptance_criteria": [
    "Approving time off creates a Google Calendar event on the center account calendar via DWD and stores event id.",
    "If calendar insert fails, request remains pending and is not approved.",
    "All actions audited (create/cancel/approve/deny).",
    "Admin list uses batched MSSQL lookup for tutor identities.",
    "No schema changes beyond adding google_calendar_event_id column (already applied).",
    "No startup DB tests."
  ]
}
